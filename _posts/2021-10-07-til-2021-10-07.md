---
layout: post
title: 2021/10/07
categories:
  - TIL
tags: 
  - 알고리즘
  - 문제해결전략
---

'[알고리즘 문제 해결 전략](https://book.algospot.com/)' 6장 관련  

### [소풍](https://www.acmicpc.net/problem/2026) 문제 회고
책의 문제와는 입력은 유사한데 참석자의 조건이 달랐다. 책의 문제는 두 명씩만 친구이면 되고, 백준OJ 문제는 모든 참석자가 친구여야 한다.  
1번부터 한 명씩 참석자 명단에 넣고 기존 참석자와 친구인지 확인하는 방법으로 재귀함수로 구현했다. (= 완전 탐색) 제출 4번만에 성공...;  


틀렸던 이유:  
1. for문 조건 (기저문을 대체해서 어떻게 탐색 범위를 줄여보다가 마지막 학생까지 탐색하지 않았다.)
2. 반복문 구현 (참석자 명단에 넣고 빼는 순서와 참석자들과 친구인지 확인하는 순서가 바뀌어 본인과 친구인지 판단해야 했다.)
3. 시작 조건이 항상 1이었다 (가장 첫 참석자가 1이 아닐 수 있으니 전체 범위를 돌면서 첫번째 참석자로 넣어보아야 한다.)


다음에는 class 빼고 list 대신 vector로 구현해보아야겠다.


#### 알고리즘 시간복잡도 계산해보기:  

학생 수 N (K <= N <= 900), 소풍 참석자 K (1 <= K <= 62), 친구 관계에 대한 정보 F (1 <= F <= 5600)  

완전 탐색해야 할 문제 공간은 다음과 같다. 루트는 참석자가 아무도 없는 상태. 루트의 자식 노드는 1번부터 N번까지 참석자가 1명씩 있는 상태이고, 이것들은 각각 자기 번호보다 큰 다음 참석자를 갖는 상태를 자식 노드로 갖는다. (따라서 참석자가 N번 한명인 노드는 자식 노드가 없다.) 트리의 깊이는 곧 참석자의 수가 되므로 최대 깊이는 K이다. 따라서 문제 공간의 크기는 N명 중에 순서 없이 K명을 뽑는 조합의 수 (N!/((N-K)!*K!))가 된다.  

이 때 참석자들과 모두 친구인지 확인하려면 최대 K-1명의 참석자와 친구관계를 확인해야 하는데 확인 결과 친구가 아닌 참석자가 있으면 그 이하는 탐색을 중단하므로 탐색할 노드는 그다지 많지 않다. (900명 중 2명을 뽑으면 900\*899/2 ~ 40.5만 쌍의 관계가 있는데 그 중 최대 5600쌍만 친구일 수 있으니 친구일 확률이 1.38% 뿐이다;;) 새로 참석자 한 명을 추가했을 때 이 사람이 기존의 모든 참석자와 친구일 확률은 2\*F/(N\*(N-1))을 기존 참석자 수만큼 제곱해야 한다. 음... 될 것 같기는 한데 수가 너무 커서 당황스럽다.  